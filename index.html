<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html-to-image/1.11.13/html-to-image.min.js" integrity="sha512-iZ2ORl595Wx6miw+GuadDet4WQbdSWS3JLMoNfY8cRGoEFy6oT3G9IbcrBeL6AfkgpA51ETt/faX6yLV+/gFJg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
      (function() {
        const originalConsole = window.console;
        window.console = {
          log: (...args) => {
            originalConsole.log(...args);
            window.parent.postMessage({ type: 'console', message: args.join(' ') }, '*');
          },
          error: (...args) => {
            originalConsole.error(...args);
            window.parent.postMessage({ type: 'console', message: 'Error: ' + args.join(' ') }, '*');
          },
          warn: (...args) => {
            originalConsole.warn(...args);
            window.parent.postMessage({ type: 'console', message: 'Warning: ' + args.join(' ') }, '*');
          }
        };

        let requestId = 0;
        let callbacksMap = new Map();
        let streamControllers = new Map();
        
        window.claude = {
          complete: (prompt) => {
            return new Promise((resolve, reject) => {
              const id = requestId++;
              callbacksMap.set(id, { resolve, reject });
              window.parent.postMessage({ type: 'claudeComplete', id, prompt }, '*');
            });
          }
        };

        window.storage = {
          get: (key, shared = false) => {
            return new Promise((resolve, reject) => {
              const id = requestId++;
              callbacksMap.set(id, { resolve, reject });
              window.parent.postMessage({ type: 'storageGet', id, key, shared }, '*');
            });
          },
          set: (key, value, shared = false) => {
            return new Promise((resolve, reject) => {
              const id = requestId++;
              callbacksMap.set(id, { resolve, reject });
              window.parent.postMessage({ type: 'storageSet', id, key, value, shared }, '*');
            });
          },
          delete: (key, shared = false) => {
            return new Promise((resolve, reject) => {
              const id = requestId++;
              callbacksMap.set(id, { resolve, reject });
              window.parent.postMessage({ type: 'storageDelete', id, key, shared }, '*');
            });
          },
          list: (prefix, shared = false) => {
            return new Promise((resolve, reject) => {
              const id = requestId++;
              callbacksMap.set(id, { resolve, reject });
              window.parent.postMessage({ type: 'storageList', id, prefix, shared }, '*');
            });
          }
        };

        let pendingBlobs = new Map();
        URL.createObjectURL = (blob) => {
          // Store the blob and create an ID and URL for it
          const blobId = `blob-${Date.now()}-${Math.random()}`;
          pendingBlobs.set(blobId, blob);
          return `blob-request://${blobId}`;
        };

        URL.revokeObjectURL = (url) => {
          // Remove the blob from our store
          const blobId = url.replace("blob-request://", "");
          pendingBlobs.delete(blobId);
        };

        const getBlobFromURL = (url) => {
          const blobId = url.replace("blob-request://", "");
          return pendingBlobs.get(blobId);
        };

        // Override global fetch with streaming support
        window.fetch = (url, init = {}) => {
          return new Promise((resolve, reject) => {
            const id = requestId++;
            const channelId = `fetch-${id}-${Date.now()}`;
            
            callbacksMap.set(id, { 
              resolve: (response) => {
                // Create a ReadableStream for the response body
                const stream = new ReadableStream({
                  start(controller) {
                    streamControllers.set(channelId, controller);
                  },
                  cancel() {
                    streamControllers.delete(channelId);
                  }
                });
                
                // Create and return the Response with the stream
                resolve(new Response(stream, {
                  status: response.status,
                  statusText: response.statusText,
                  headers: response.headers
                }));
              },
              reject,
              channelId
            });
            
            window.parent.postMessage({
              type: 'proxyFetch',
              id,
              url,
              init,
              channelId
            }, '*');
          });
        };

        window.addEventListener('message', async (event) => {
          if (event.data.type === 'takeScreenshot') {
            const rootElement = document.getElementById('artifacts-component-root-html');
            if (!rootElement) {
              window.parent.postMessage({
                type: 'screenshotError',
                error: new Error('Root element not found'),
              }, '*');
            }
            const screenshot = await htmlToImage.toPng(rootElement, {
              imagePlaceholder:
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAA1JREFUGFdjePDgwX8ACOQDoNsk0PMAAAAASUVORK5CYII=",
            });
            window.parent.postMessage({
              type: 'screenshotData',
              data: screenshot,
            }, '*');
          } else if (event.data.type === 'claudeComplete') {
            const callback = callbacksMap.get(event.data.id);
            if (event.data.error) {
              callback.reject(new Error(event.data.error));
            } else {
              callback.resolve(event.data.completion);
            }
            callbacksMap.delete(event.data.id);
          } else if (event.data.type === 'proxyFetchResponse') {
            const callback = callbacksMap.get(event.data.id);
            if (event.data.error) {
              callback.reject(new Error(event.data.error));
              callbacksMap.delete(event.data.id);
            } else {
              // Initial response with headers, status, etc.
              callback.resolve({
                status: event.data.status,
                statusText: event.data.statusText,
                headers: event.data.headers
              });
              // Don't delete the callback yet if streaming
              if (!event.data.body) {
                callbacksMap.delete(event.data.id);
              }
            }
          } else if (event.data.type === 'proxyFetchStream') {
            // Handle streaming data chunks
            const controller = streamControllers.get(event.data.channelId);
            if (controller) {
              if (event.data.error) {
                controller.error(new Error(event.data.error));
                streamControllers.delete(event.data.channelId);
              } else if (event.data.done) {
                controller.close();
                streamControllers.delete(event.data.channelId);
                // Clean up the callback
                const callback = Array.from(callbacksMap.entries()).find(
                  ([_, value]) => value.channelId === event.data.channelId
                );
                if (callback) {
                  callbacksMap.delete(callback[0]);
                }
              } else if (event.data.chunk) {
                controller.enqueue(new Uint8Array(event.data.chunk));
              }
            }
          } else if (event.data.type === 'storageGet') {
            const callback = callbacksMap.get(event.data.id);
            if (event.data.error) {
              callback.reject(new Error(event.data.error));
            } else {
              callback.resolve(event.data.result);
            }
            callbacksMap.delete(event.data.id);
          } else if (event.data.type === 'storageSet') {
            const callback = callbacksMap.get(event.data.id);
            if (event.data.error) {
              callback.reject(new Error(event.data.error));
            } else {
              callback.resolve(event.data.result);
            }
            callbacksMap.delete(event.data.id);
          } else if (event.data.type === 'storageDelete') {
            const callback = callbacksMap.get(event.data.id);
            if (event.data.error) {
              callback.reject(new Error(event.data.error));
            } else {
              callback.resolve(event.data.result);
            }
            callbacksMap.delete(event.data.id);
          } else if (event.data.type === 'storageList') {
            const callback = callbacksMap.get(event.data.id);
            if (event.data.error) {
              callback.reject(new Error(event.data.error));
            } else {
              callback.resolve(event.data.result);
            }
            callbacksMap.delete(event.data.id);
          }
        });

        window.addEventListener('click', (event) => {
          const isEl = event.target instanceof HTMLElement;
          if (!isEl) return;
    
          // find ancestor links
          const linkEl = event.target.closest("a");
          if (!linkEl || !linkEl.href) return;
    
          event.preventDefault();
          event.stopImmediatePropagation();
    
          if (linkEl.href.startsWith("blob-request:")) {
            const blob = getBlobFromURL(linkEl.href);
            if (!blob) return;
            void blob.arrayBuffer().then((data) => {
              window.parent.postMessage({
                type: "downloadFile",
                filename: linkEl.download,
                data,
                mimeType: blob.type || "application/octet-stream",
              });
            });
          } else if (linkEl.href.startsWith("data:")) {
            const [header, base64Data] = linkEl.href.split(",");
            const mimeMatch = header.match(/data:([^;]+)/);
            const mimeType = mimeMatch ? mimeMatch[1] : "application/octet-stream";
            const binaryString = atob(base64Data);
            const data = Uint8Array.from(binaryString, (c) =>
              c.charCodeAt(0),
            ).buffer;
            window.parent.postMessage({
              type: "downloadFile",
              filename: linkEl.download,
              data,
              mimeType,
            });
          } else {
            let linkUrl;
            try {
              linkUrl = new URL(linkEl.href);
            } catch (error) {
              return;
            }
    
            if (linkUrl.hostname === window.location.hostname) return;
      
            window.parent.postMessage({
              type: 'openExternal',
              href: linkEl.href,
            }, '*');
          }
      });

        const originalOpen = window.open;
        window.open = function (url) {
          window.parent.postMessage({
            type: "openExternal",
            href: url,
          }, "*");
        };

        window.addEventListener('error', (event) => {
          window.parent.postMessage({ type: 'console', message: 'Uncaught Error: ' + event.message }, '*');
        });
      })();
    </script>
  
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BigHead Character Cooker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: linear-gradient(135deg, #2d3250 0%, #1f2937 100%);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            padding: 30px;
            max-width: 1400px;
            width: 100%;
            border: 1px solid rgba(139, 92, 246, 0.3);
        }

        h1 {
            text-align: center;
            color: #e0e7ff;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 0 0 20px rgba(139, 92, 246, 0.5);
        }

        .main-content {
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }

        .viewing-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: sticky;
            top: 20px;
        }

        .canvas-container {
            position: relative;
            width: 500px;
            height: 500px;
            border: 3px solid #8b5cf6;
            border-radius: 15px;
            overflow: hidden;
            background: #1e293b;
            box-shadow: 0 10px 30px rgba(139, 92, 246, 0.3), 0 0 40px rgba(139, 92, 246, 0.2);
        }

        /* Mobile toggle button */
        .mobile-toggle {
            display: none;
            width: 100%;
            padding: 15px;
            margin-bottom: 15px;
            background: linear-gradient(135deg, #8b5cf6 0%, #6366f1 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(139, 92, 246, 0.4);
            transition: transform 0.2s;
        }

        .mobile-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(139, 92, 246, 0.6);
        }

        .mobile-toggle.active {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
        }

        #mainCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        .export-btn {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 18px;
            font-weight: bold;
            color: white;
            background: linear-gradient(135deg, #8b5cf6 0%, #6366f1 100%);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 5px 15px rgba(139, 92, 246, 0.4), 0 0 20px rgba(139, 92, 246, 0.3);
        }

        .export-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(139, 92, 246, 0.6), 0 0 30px rgba(139, 92, 246, 0.4);
        }

        .export-btn:active {
            transform: translateY(0);
        }

        .categories-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-height: 700px;
            overflow-y: auto;
            padding-right: 10px;
        }

        .categories-panel::-webkit-scrollbar {
            width: 8px;
        }

        .categories-panel::-webkit-scrollbar-track {
            background: #1e293b;
            border-radius: 10px;
        }

        .categories-panel::-webkit-scrollbar-thumb {
            background: #8b5cf6;
            border-radius: 10px;
        }

        .categories-panel::-webkit-scrollbar-thumb:hover {
            background: #a78bfa;
        }

        .category {
            background: linear-gradient(135deg, #374151 0%, #1f2937 100%);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: transform 0.2s, box-shadow 0.2s;
            border: 1px solid rgba(139, 92, 246, 0.2);
        }

        .category:hover {
            transform: translateX(5px);
            box-shadow: 0 8px 20px rgba(139, 92, 246, 0.3);
            border-color: rgba(139, 92, 246, 0.4);
        }

        .category-header {
            font-weight: bold;
            color: #c4b5fd;
            margin-bottom: 10px;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 0 10px rgba(139, 92, 246, 0.3);
        }

        .category-content {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .category-preview {
            width: 80px;
            height: 80px;
            border: 2px solid #8b5cf6;
            border-radius: 10px;
            overflow: hidden;
            background: #1e293b;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 3px 10px rgba(139, 92, 246, 0.3);
        }

        .category-preview img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
        }

        .category-controls {
            display: flex;
            flex-direction: column;
            gap: 5px;
            flex: 1;
        }

        .category-name {
            font-size: 14px;
            color: #e0e7ff;
            font-weight: 500;
            min-height: 20px;
        }

        .category-arrows {
            display: flex;
            gap: 10px;
        }

        .arrow-btn {
            flex: 1;
            padding: 8px 15px;
            background: #1e293b;
            border: 2px solid #8b5cf6;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            color: #c4b5fd;
            transition: all 0.2s;
            font-size: 16px;
        }

        .arrow-btn:hover {
            background: #8b5cf6;
            color: white;
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(139, 92, 246, 0.5);
        }

        .arrow-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .arrow-btn:disabled:hover {
            background: #1e293b;
            color: #c4b5fd;
            transform: scale(1);
            box-shadow: none;
        }

        .loading {
            text-align: center;
            color: #c4b5fd;
            font-size: 18px;
            padding: 20px;
        }

        @media (max-width: 1200px) {
            .main-content {
                flex-direction: column;
            }

            .viewing-panel {
                position: static;
                width: 100%;
            }

            .canvas-container {
                width: 100%;
                max-width: 500px;
                height: auto;
                aspect-ratio: 1;
            }

            .categories-panel {
                max-height: none;
            }

            .mobile-toggle {
                display: block;
            }

            .categories-panel.collapsed {
                display: none;
            }

            .categories-panel.expanded {
                display: flex;
            }
        }

        @media (min-width: 1201px) {
            .categories-panel {
                display: flex !important;
            }
        }
    </style>
</head>
<body id="artifacts-component-root-html">
    <div class="container">
        <h1>üé®üçî BigHead Character Cooker</h1>
        <button class="mobile-toggle" id="mobileToggle" onclick="toggleCategories()">
            üìã Show Categories
        </button>
        <div class="main-content">
            <div class="viewing-panel">
                <div class="canvas-container">
                    <canvas id="mainCanvas" width="1000" height="1000"></canvas>
                </div>
                <button class="export-btn" onclick="exportImage()">üíæ Export PNG (1000x1000)</button>
            </div>
            <div class="categories-panel collapsed" id="categoriesPanel">
                <div class="loading">Loading images...</div>
            </div>
        </div>
    </div>

    <script>
        // Configuration - Update these arrays with your actual image filenames
        const imageData = {
            EYES: ['eyes1.png', 'eyes2.png', 'eyes3.png'],
            MOUTH: ['mouth1.png', 'mouth2.png', 'mouth3.png'],
            HEAD: ['head1.png', 'head2.png', 'head3.png'],
            OUTFIT: ['outfit1.png', 'outfit2.png', 'outfit3.png'],
            TEXTURE: ['texture1.png', 'texture2.png', 'texture3.png'],
            BODY: ['body1.png', 'body2.png', 'body3.png'],
            BACKGROUND: ['background1.png', 'background2.png', 'background3.png']
        };

        // Layer order (top to bottom in rendering)
        const layerOrder = ['EYES', 'MOUTH', 'HEAD', 'OUTFIT', 'TEXTURE', 'BODY', 'BACKGROUND'];

        // State management
        const state = {
            currentIndices: {},
            loadedImages: {},
            categories: layerOrder
        };

        // Initialize indices
        layerOrder.forEach(category => {
            state.currentIndices[category] = 0;
            state.loadedImages[category] = [];
        });

        // Canvas setup
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');

        // Preload all images
        async function preloadImages() {
            const promises = [];
            
            for (const category of layerOrder) {
                const categoryImages = imageData[category];
                
                for (let i = 0; i < categoryImages.length; i++) {
                    const promise = new Promise((resolve, reject) => {
                        const img = new Image();
                        img.crossOrigin = "anonymous";
                        img.onload = () => {
                            state.loadedImages[category][i] = img;
                            resolve();
                        };
                        img.onerror = () => {
                            console.warn(`Failed to load: ${category}/${categoryImages[i]}`);
                            state.loadedImages[category][i] = null;
                            resolve(); // Resolve anyway to continue
                        };
                        img.src = `${category}/${categoryImages[i]}`;
                    });
                    promises.push(promise);
                }
            }

            await Promise.all(promises);
            console.log('All images loaded');
        }

        // Render the character
        function renderCharacter() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw layers in reverse order (background first, eyes last)
            for (let i = layerOrder.length - 1; i >= 0; i--) {
                const category = layerOrder[i];
                const index = state.currentIndices[category];
                const img = state.loadedImages[category][index];

                if (img) {
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                }
            }
        }

        // Update category preview
        function updateCategoryPreview(category) {
            const preview = document.querySelector(`#preview-${category}`);
            const nameDisplay = document.querySelector(`#name-${category}`);
            const index = state.currentIndices[category];
            const img = state.loadedImages[category][index];
            const filename = imageData[category][index];

            if (preview && img) {
                preview.innerHTML = `<img src="${img.src}" alt="${category}">`;
            }

            if (nameDisplay) {
                nameDisplay.textContent = filename ? filename.replace('.png', '') : 'None';
            }

            updateArrowStates(category);
        }

        // Update arrow button states
        function updateArrowStates(category) {
            const prevBtn = document.querySelector(`#prev-${category}`);
            const nextBtn = document.querySelector(`#next-${category}`);
            const index = state.currentIndices[category];
            const maxIndex = imageData[category].length - 1;

            if (prevBtn) {
                prevBtn.disabled = index === 0;
            }
            if (nextBtn) {
                nextBtn.disabled = index === maxIndex;
            }
        }

        // Navigate category
        function navigateCategory(category, direction) {
            const currentIndex = state.currentIndices[category];
            const maxIndex = imageData[category].length - 1;
            let newIndex = currentIndex + direction;

            // Clamp to valid range
            if (newIndex < 0) newIndex = 0;
            if (newIndex > maxIndex) newIndex = maxIndex;

            state.currentIndices[category] = newIndex;
            updateCategoryPreview(category);
            renderCharacter();
        }

        // Build UI
        function buildUI() {
            const panel = document.getElementById('categoriesPanel');
            panel.innerHTML = '';

            layerOrder.forEach(category => {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'category';
                
                const filename = imageData[category][0] ? imageData[category][0].replace('.png', '') : 'None';
                
                categoryDiv.innerHTML = `
                    <div class="category-header">${category}</div>
                    <div class="category-content">
                        <div class="category-preview" id="preview-${category}"></div>
                        <div class="category-controls">
                            <div class="category-name" id="name-${category}">${filename}</div>
                            <div class="category-arrows">
                                <button class="arrow-btn" id="prev-${category}" onclick="navigateCategory('${category}', -1)">‚óÄ Prev</button>
                                <button class="arrow-btn" id="next-${category}" onclick="navigateCategory('${category}', 1)">Next ‚ñ∂</button>
                            </div>
                        </div>
                    </div>
                `;
                
                panel.appendChild(categoryDiv);
            });

            // Update all previews
            layerOrder.forEach(category => {
                updateCategoryPreview(category);
            });
        }

        // Export PNG
        function exportImage() {
            const link = document.createElement('a');
            link.download = `character-${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // Toggle categories panel on mobile
        function toggleCategories() {
            const panel = document.getElementById('categoriesPanel');
            const toggleBtn = document.getElementById('mobileToggle');
            
            if (panel.classList.contains('collapsed')) {
                panel.classList.remove('collapsed');
                panel.classList.add('expanded');
                toggleBtn.textContent = '‚ùå Hide Categories';
                toggleBtn.classList.add('active');
            } else {
                panel.classList.remove('expanded');
                panel.classList.add('collapsed');
                toggleBtn.textContent = 'üìã Show Categories';
                toggleBtn.classList.remove('active');
            }
        }

        // Initialize app
        async function init() {
            await preloadImages();
            buildUI();
            renderCharacter();
        }

        // Start the app
        init();
    </script>
</body>
</html>
